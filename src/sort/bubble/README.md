# Bubble Sort
- 시간 복잡도:
  - 평균: O(n^2)
  - 최악: O(n^2)
- 공간 복잡도:
  - O(1)

# 특징
- 구현이 쉽지만 느리다.

# 장점
- 구현이 쉽다.

# 단점
- 느리다.

# 동작 원리
n개의 데이터에서 2개의 인접한 데이터를 1부터 n까지 순차적으로 선택하며 비교, 정렬해 가는 알고리즘<br>
오름차순의 경우 첫 번째 루프를 돌고 나면 맨 마지막에 가장 큰 값이 위치함. (내림차순은 반대)<br>
다시 2개의 인접한 데이터를 n-1 까지 비교. 이를 n번 반복

아래 배열을 버블 정렬을 통해 오름차순으로 정렬 예제<br>
|9|5|7|2|8|1|

- 9와 5를 비교, 9가 더 크므로 5와 스왑<br>
|5|9|7|2|8|1|

- 9와 7을 비교, 9가 더 크므로 7과 스왑<br>
|5|7|9|2|8|1|

- 9와 2를 비교, 9가 더 크므로 2와 스왑<br>
|5|7|2|9|8|1|

- 9와 8을 비교, 9가 더 크므로 8과 스왑<br>
|5|7|2|8|9|1|

- 9와 1을 비교, 9가 더 크므로 1과 스왑<br>
|5|7|2|8|1|9|

이제 맨 마지막에 가장 큰 요소가 정렬되었음.<br>
따라서 이를 n번 반복하면 최종적으로 아래와 같은 정렬된 배열을 얻을 수 있음<br>
|1|2|5|7|8|9|

# 성능
비교 횟수는 (n-1) + (n-2) + (n-3) + ... + 3 + 2 + 1 이므로 총 n * (n / 2) 가 되므로 시간 복잡도가 O(n^2) 이 됨<br>
공간 복잡도의 경우 입력된 데이터 (배열) 1개만 필요하므로 O(1) 이 됨

# 언제 쓸까?
데이터 양이 적을 경우 간단하게 구현해서 사용할 만 함<br>
하지만 데이터 양이 많을 경우 사용하면 망함<br>

# 구현
```java
int[] arr = Arrays.asList(9, 5, 7, 2, 8, 1);
int listLength = arr.length;
int boundary = listLength - 1;

for (int i = 0; i < listLength; i++) {
  for (int j = 0; j < boundary - i; j++) {
    if (arr[j] > arr[j + 1]) {
      int temp = arr[j];
      arr[j] = arr[j + 1];
      arr[j + 1] = temp;
    }
  }
}
```
