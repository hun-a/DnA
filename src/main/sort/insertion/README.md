# Insertion Sort
- 시간 복잡도:
  - 평균: O(n^2)
  - 최악: O(n^2)
- 공간 복잡도:
  - O(n)

# 장점
- 이미 정렬이 되어 있을 경우 성능이 좋다 (무려 O(n)!!)

# 단점
- 최악의 경우 느리다. O(n^2)

# 동작 원리
삽입할 위치를 지정할 변수를 하나 선언<br>
시작시 배열의 첫 번째 인덱스는 위에서 선언한 변수로 지정하고, 두 번째 인덱스부터 비교 시작<br>
즉, 삽입할 위치를 지정할 변수는 배열의 비교 인덱스보다 1 작은 크기가 됨<br>
이제 두 인덱스를 통해 배열의 값을 비교<br>
만약, 삽입할 위치를 지정할 변수의 값이 작거나 같다면<br>
인덱스와 삽입할 위치를 지정한 변수를 1씩 증가<br>
아니라면 두 값의 위치를 변경 후 인덱스와 삽입할 위치를 지정한 변수를 1씩 감소시킨 후 인덱스가 0보다 클 동안 비교 반복<br>
위 과정을 n-1 번 반복

아래 배열을 삽입 정렬을 통해 오름차순으로 정렬 예제<br>
`|9|5|7|2|8|1|`

- 삽입할 위치를 저장한 변수 0, 인덱스 1 을 비교: `9 > 5` 이므로 두 값의 위치를 변경<br>
`|5|9|7|2|8|1|`<br>
이후 인덱스가 0 이므로 다음 요소 비교

- 삽입할 위치를 저장한 변수 1, 인덱스 2 를 비교: `9 > 7` 이므로 두 값의 위치를 변경<br>
`|5|7|9|2|8|1|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `5 > 7` 이므로 다음 요소 비교

- 삽입할 위치를 저장한 변수 2, 인덱스 3 을 비교: `9 > 2` 이므로 두 값의 위치를 변경<br>
`|5|7|2|9|8|1|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `7 > 2` 이므로 두 값의 위치를 변경<br>
`|5|2|7|9|8|1|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `5 > 2` 이므로 두 값의 위치를 변경<br>
`|2|5|7|9|8|1|`<br>
이후 인덱스가 0 이므로 다음 요소 비교 <- *최악*

- 삽입할 위치를 저장한 변수 3, 인덱스 4 을 비교: `9 > 8` 이므로 두 값의 위치를 변경<br>
`|2|5|7|8|9|1|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `7 > 8` 이므로 다음 요소 비교

- 삽입할 위치를 저장한 변수 3, 인덱스 4 을 비교: `9 > 1` 이므로 두 값의 위치를 변경<br>
`|2|5|7|8|1|9|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `8 > 1` 이므로 두 값의 위치를 변경<br>
`|2|5|7|1|8|9|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `7 > 1` 이므로 두 값의 위치를 변경<br>
`|2|5|1|7|8|9|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `5 > 1` 이므로 두 값의 위치를 변경<br>
`|2|1|5|7|8|9|`<br>
인덱스와 삽입할 위치를 저장한 변수의 값을 1 감소시켜서 비교했더니 `2 > 1` 이므로 두 값의 위치를 변경<br>
`|1|2|5|7|8|9|`<br>
이후 인덱스가 0 이므로 다음 요소 비교 <- *더 최악*

- n-1 번의 비교가 모두 끝났으므로 종료

# 성능
전체 반복 횟수는 2 부터 n 까지이므로 총 n-1 번의 반복을 수행하며,<br>
운좋게 정렬된 값이 있다면 내부 반복을 돌지 않으므로 n 번의 비교만으로 정렬이 끝난다.<br>
하지만 최악의 경우 _(반대로 정렬된 경우)_ 내부 반복을 모두 돌며 아래와 같은 멋진 성능을 경험할 수 있다.<br>
1 + 2 + 3 + ... + (n - 1) -> n(n-1)/2 -> O(n^2)

# 언제 쓸까?
장점과 같이 이미 정렬 되어 있을 경우 쓰면 좋겠다. (아이러니하네??)

# 구현
```java
int[] arr = int[] arr = new int[]{ 9, 5, 7, 2, 8, 1 };
int length = arr.length;

for (int i = 1; i < length; i++) {
  for (int j = i, compareIndex = (i - 1); j > 0; j--, compareIndex--) {
    if (arr[compareIndex] <= arr[j]) {
      break;
    } else {
      int temp = arr[compareIndex];
      arr[compareIndex] = arr[j];
      arr[j] = temp;
    }
  }
}
```java
