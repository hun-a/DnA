# Shell Sort
- 시간 복잡도:
  - 평균: O(n^1.5)
  - 최악: O(n^2)
- 공간 복잡도:
  - O(n)

# 장점
- 삽입 정렬보다 빠르다

# 단점
- 구현이 쉽지 않다. 그리고 이해하기도 어렵다.
- 성능 분석이 까다롭다.

# 동작 원리
먼저 역사를 보면, 삽입 정렬의 단점을 보완하기 위해 [Donald Shell](https://en.wikipedia.org/wiki/Donald_Shell)이란 분께서 1958년에 고안한 알고리즘이다.<br>
삽입 정렬의 단점이란 바로 정렬하려는 방향과 반대로 정렬되어 있는 경우 굉장한 시간을 소모한다.<br>
이러한 이유로 배열을 특정 간격으로 나누어서 미리 삽입 정렬을 수행하고(원소의 개수가 적으면 빠르니깐)<br>
간격을 좁혀가면서 계속해서 삽입 정렬을 수행하게 된다.<br>
간격은 최종적으로 1로 수렴하고, 마침내 전체에 대한 삽입 정렬을 수행한다. ~참 쉽죠?~ <br>

자 그럼 예제를 한번 보자.<br>
배열은 `|81|7|13|5|29|30|99|1|63|25|4|92|47|50|32|` 이다.<br>
간격을 우리는 `k` 라고 두고 `k = k / 3 + 1` 로 계속해서 간격을 줄여나갈 것이다.

- 초기 `k의` 값은 배열의 전체 길이로 초기화 한다. 즉, 위의 배열에 대한 길이 15가 `k`의 초기 값이다.<br>
그럼 맨 처음 간격은 `k = k / 3 + 1` 에 의해 6이 될 것이다.<br>
즉, 6 간격만큼 있는 값들을 하나의 배열로 생각해서 삽입 정렬을 수행한다.<br>
6 간격만큼 나눠서 배열을 보면 다음과 같은 형태이다. _(물론 알고리즘에서 실제로 배열을 나누진 않고, 인덱스만 k만큼 증가시켜 계산하면 된다)_ <br>
`|81|99|47|` -> 0번째 값부터 간격이 6씩 떨어진 값을 삽입 정렬 -> `|47|81|99|`<br>
`|7|1|50|` -> 1번째 값부터 간격이 6씩 떨어진 값들을 삽입 정렬 -> `|1|7|50|`<br>
`|13|63|32|` -> 2번째 값부터 간격이 6씩 떨어진 값들을 삽입 정렬 -> `|13|32|63|`<br>
`|5|25|` -> 3번째 값부터 간격이 6씩 떨어진 값들을 삽입 정렬 -> `|5|25|`<br>
`|29|4|` -> 4번째 값부터 간격이 6씩 떨어진 값들을 삽입 정렬 -> `|4|29|`<br>
`|30|92|` -> 5번째 값부터 간격이 6씩 떨어진 값들을 삽입 정렬 -> `|30|92|`<br>
위의 6개의 작은 배열을 하나의 배열로 확인하면 다음과 같다.<br>
`|47|1|13|5|4|30|81|7|32|25|29|92|99|50|63|`

- 이제 두 번째 `k`의 값을 구해보자. `k = k / 3 + 1`에 의해 3이 된다.<br>
다시 3 간격만큼 배열을 보기좋게 나눠서 삽입 정렬 후 전체 배열이 어떻게 되었나 확인해보자. _(역시 실제 알고리즘은 배열을 3 간격만큼 나누지 않는다)_<br>
`|47|5|81|25|99|` -> 0번째 값부터 간격이 3씩 떨어진 값들의 삽입 정렬 -> `|5|25|47|81|99|`<br>
`|1|4|7|29|50|` -> 1번째 값부터 간격이 3씩 떨어진 값들의 삽입 정렬 -> `|1|4|7|29|50|`<br>
`|13|30|32|92|63|` -> 2번째 값부터 간격이 3씩 떨어진 값들의 삽입 정렬 -> `|13|30|32|63|92|`<br>
위의 3개의 작은 배열을 하나의 배열로 확인하면 다음과 같다.<br>
`|5|1|13|25|4|30|47|7|32|81|29|63|99|50|92|`

- 이제 세 번째 `k`의 값을 구해보자. `k = k / 3 + 1`에 의해 2가 된다.<br>
다시 2 간격만큼 배열을 보기 좋게 나눠서 삽입 정렬 후 전체 배열이 어떻게 되었나 확인해보자.<br>
`|5|13|4|47|32|29|99|92|` -> 0 번째 값부터 간격이 2씩 떨어진 값들의 삽입 정렬 -> `|4|5|13|29|32|47|92|99|`<br>
`|1|25|30|7|81|63|50|` -> 1 번째 값부터 간격이 2씩 떨어진 값들의 삽입 정렬 -> `|1|7|25|30|50|63|81|`<br>
위의 2개의 작은 배열을 하나의 배열로 확인하면 다음과 같다.<br>
`|4|1|5|7|13|25|29|30|32|50|47|63|92|81|99|`<br>
어느정도 정렬이 되어 있는 것 같다.

- 이제 네 번째 `k` 값을 구해보자. `k = k / 3 + 1` 에 의해 1이 되고, 간격이 1이라는 의미는 전체 값들에 대해 삽입 정렬을 수행하면 된다는 말이다.<br>
삽입 정렬 결과는 다음과 같다.<br>
`|1|4|5|7|13|25|29|30|32|47|50|63|81|92|99|`<br>
즉, 모든 값들의 정렬이 완료 되었다.

# 성능
- 효율적인 정렬 알고리즘의 성능은 O(nlogn)인데 쉘 정렬은 그에 못미치는 O(n^1.5) 이다.<br>
또한 간격 k의 값을 어떻게 선택하느냐에 따라 성능이 크게 좌우된다.

# 언제 쓸까?
- 삽입 정렬이나 버블 정렬에 비해 자료의 양이 많을 경우 더 빠르기는 하므로 임베이디드의 정렬에서 쓰이기는 한다고 한다. __믿거나 말거나__

# 구현
```java
int[] arr = {81, 7, 13, 5, 29, 30, 99, 1, 63, 25, 4, 92, 47, 50, 32};
int gap = arr.length;
do {
  gap = gap / 3 + 1;
  for (int i = 0; i < gap; i++) {
    for (int separatedArrayIndex = i + gap; separatedArrayIndex < arr.length; separatedArrayIndex += gap) {
      for (int insertionIndex = separatedArrayIndex; insertionIndex - gap >= 0; insertionIndex--) {
        if (arr[insertionIndex - gap] < arr[insertionIndex]) {
          break;
        } else {
          int temp = arr[insertionIndex - gap];
          arr[insertionIndex - gap] = arr[insertionIndex];
          arr[insertionIndex] = temp;
        }
      }
    }
  }
} while (gap != 1);
```
