# Bubble Sort
- 시간 복잡도:
  - 평균: O(n^2)
  - 최악: O(n^2)
- 공간 복잡도:
  - O(n)

# 장점
- 알고리즘이 사람이 정렬하는 방식과 같다. (이해가 쉽다)

# 단점
- 느리다. (하지만 버블 정렬보다는 빠르다)

# 동작 원리
배열의 맨 처음 요소를 기억해 놓고, 나머지 `n-1`개의 요소들 중 가장 작은 값을 선택<br>
기억한 요소와 가장 작은 값을 비교하여 가장 작은 값이 작다면 두 요소의 위치를 변경<br>
아니라면 기억한 요소 다음 요소를 기억 후 위 과정을 반복<br>

아래 배열을 선택 정렬을 통해 오름차순으로 정렬 예제<br>
`|9|5|7|2|8|1|`

- 첫 번째 스텝에서 인덱스는 0이고, 인덱스에 해당하는 값 9를 기억해 놓는다.<br>
인덱스 다음 요소에서 마지막 n개의 요소 중 가장 최솟값 1을 찾는다.<br>
9 > 1 이므로 두 요소의 위치를 변경한다.<br>
배열의 상태는 `|1|5|7|2|8|9|` 가 된다.

- 두 번째 스텝에서 인덱스는 1이고, 인덱스에 해당하는 값 5를 기억해 놓는다.<br>
인덱스 다음 요소에서 마지막 n개의 요소 중 가장 최솟값 2를 찾는다.<br>
5 > 2 이므로 두 요소의 위치를 변경한다.<br>
배열의 상태는 `|1|2|7|5|8|9|` 가 된다.

- 세 번째 스텝에서 인덱스는 2이고, 인덱스에 해당하는 값 7을 기억해 놓는다.<br>
인덱스 다음 요소에서 마지막 n개의 요소 중 가장 최솟값 5를 찾는다.<br>
7 > 5 이므로 두 요소의 위치를 변경한다.<br>
배열의 상태는 `|1|2|5|7|8|9|` 가 된다. _(사실상 정렬이 되었지만 계속 돌아간다...)_

- 네 번째 스텝에서 인덱스는 3이고, 인덱스에 해당하는 값 7을 기억해 놓는다. _(7이 또 나왔는데 또 비교??)_ <br>
인덱스 다음 요소에서 마지막 n개의 요소 중 가장 최솟값 8를 찾는다.<br>
7 > 8 이므로 아무런 변화가 일어나지 않는다.<br>
배열의 상태는 `|1|2|5|7|8|9|` 가 된다. _(여기서 끝내고 싶다...)_

- 다섯 번째 스텝에서 인덱스는 4이고, 인덱스에 해당하는 값 8을 기억해 놓는다.<br>
인덱스 다음 요소에서 마지막 n개의 요소 중 가장 최솟값 9를 찾는다.<br>
8 > 9 이므로 아무런 변화가 일어나지 않는다.<br>
배열의 상태는 `|1|2|5|7|8|9|` 가 된다.

- 여섯 번째 스텝이 가기 전에, 인덱스가 5가 되므로 더 이상 찾을 최솟값이 없다.<br>
따라서 모든 정렬이 완료된 것으로 판단하고 종료한다.

# 성능
맨 처음 `n-1`개의 요소 중 최솟값을 찾고,<br>
다음은 `n-2`개의 요소 중 최솟값을 찾고<br>
쭉~ 반복 하다가 마지막에 최솟값을 찾을 요소가 1개가 되면 끝난다.<br>
즉, (n-1) + (n-2) + ... + 2 + 1 이므로 (n*n)/2 가 된다.<br>
즉, 시간 복잡도는 O(n^2)이 된다.<br>
공간 복잡도는 하나의 배열에서 이루어 지므로 O(n) 이다.

# 언제 쓸까?
정렬하려는 요소의 갯수가 작을 경우 쓰면 좋다. 아니라면 쓰지 말자.

# 구현
